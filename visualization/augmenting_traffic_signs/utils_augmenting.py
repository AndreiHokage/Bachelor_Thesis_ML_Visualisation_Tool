import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
import tensorflow.keras as tfkeras

from visualization.augmenting_traffic_signs.networks_inpainting import create_generator_unet
from visualization.config import IMAGE_SIZE, WEIGHT_INIT, CHECKPOINT_PATH, EPOCH_INPAINTING, MODEL_EHC_PATH


def load_model_inpainting():
    generator = create_generator_unet(IMAGE_SIZE, WEIGHT_INIT)
    generator.load_weights(CHECKPOINT_PATH + f'/gen_e{EPOCH_INPAINTING}')
    return generator

def load_model_sign_embed():
    return tfkeras.models.load_model(MODEL_EHC_PATH)

'''
Computes the inverse of a mask.
:param mask: a numpy array (H, W, 1) in [-1, 1]. White = 1 BLACK = -1
:return: the inverse of the mask: a numpy array in [-1, 1]
'''
def compute_inverse_mask(mask):
    copy_mask = np.copy(mask)
    for i in range(len(copy_mask)):
        for j in range(len(copy_mask[0])):
            copy_mask[i][j] = -copy_mask[i][j]
    return copy_mask

'''
Given an image and a mask, transform the pixels from the image into black pixels 
if they are matching with the black pixels from the mask ( x operation )
:param image: numpy array (128, 128, 3) with values in {-1, 1}
:param mask: numpy array (128, 128, 1) with values in {-1, 1}; -1 = black; 1 = white 
:return: a numpy array with values in {-1, 1}
'''
def compute_get_cropped_image_from_mask(image, mask):
    copy_image = np.copy(image)
    copy_mask = np.copy(mask)

    for i in range(len(copy_image)):
        for j in range(len(copy_image[0])):
            # the pixels from image corresponding to the black pixels from mask become black
            copy_image[i][j] = -1 if all(copy_mask[i][j] == -1) else copy_image[i][j]
    return copy_image

'''
Given a background patch and a icon, turns the pixels from the background image into the pixels 
from the icon image if they are black, otherwise it keeps the same one pixels. ( + operation )
:param background: numpy array (128, 128, 3) with values in {-1, 1}
:param icon: numpy array (128, 128, 3) with values in {-1, 1}; -1 = black; 1 = white 
:return: a numpy (128, 128, 3) array with values in {-1, 1}
'''
def compute_concatenate_background_and_icon(background, icon):
    copy_background = np.copy(background)
    copy_icon = np.copy(icon)
    for i in range(len(copy_background)):
        for j in range(len(copy_background[0])):
            copy_background[i][j] = copy_icon[i][j] if all(copy_background[i][j] == -1) else copy_background[i][j]
    return copy_background

'''
Create the input for G2 by putting togheter the inpainting_patch, icon, mask images
:param inpainting_patch: a tf tensor (H, W, _) with pixels values in {-1, 1}
:param icon: a tf tensor (H, W, _) with pixels values in {-1, 1}
:param mask: a tf tensor (H, W, 1) with pixels values in {-1, 1}
:return: the image with the traffic icon sign embedded in the center of inpainted_patch.
The image is normalized in {-1, 1} (H, W, _)
'''
def create_input_generator(inpainting_patch, icon, mask):
    inverse_mask = compute_inverse_mask(np.array(mask))
    background_patch = compute_get_cropped_image_from_mask(np.array(inpainting_patch), inverse_mask)
    input_generator = tf.convert_to_tensor(compute_concatenate_background_and_icon(background_patch, np.array(icon)))
    return input_generator


'''
Performs the preprocessing steps to get the final image from the output genrator image
:param inpainting_patch_image: a tf tensor (H, W, _) with pixel values in {-1, 1}
:param mask_image: a tf tensor (H, W, 1) with pixel values in {-1, 1}
:param prediction: a tf tensor (H, W, 3) with pixel values in {-1, 1} generated by the G2
:return: a tf tensor (H, W, _) with values in {-1, 1}
'''
def postprocessing_realistic_patch(inpainting_patch_image, mask_image, prediction):
    extract_enhacement_sign = compute_get_cropped_image_from_mask(np.array(prediction), np.array(mask_image))
    background_inapainting = compute_get_cropped_image_from_mask(np.array(inpainting_patch_image),
                                                                 compute_inverse_mask(np.array(mask_image)))
    output = tf.convert_to_tensor(compute_concatenate_background_and_icon(background_inapainting,
                                                                          extract_enhacement_sign))
    return output